"use server"

import { prisma } from "@/lib/prisma"
import { auth } from "@/auth"
import { revalidatePath } from "next/cache"
import { resolveCommissionRate, resolveParentCommissionRate } from "@/lib/affiliate/commission"
import type { OrderStatus } from "@prisma/client"
import { notifyCustomerStatusChanged } from "@/lib/email/notify"

async function requireAdmin() {
  const session = await auth()
  if (session?.user?.role !== "ADMIN" && session?.user?.role !== "SUPER_ADMIN") {
    throw new Error("Unauthorized")
  }
  return session
}

export async function confirmPayment(orderId: string) {
  const session = await requireAdmin()

  const order = await prisma.order.findUnique({
    where: { id: orderId },
    include: {
      payment: true,
      user: { select: { email: true } },
      affiliate: { include: { parent: true } },
      items: true,
    },
  })

  if (!order || !order.payment) return { error: "Order not found" }
  if (order.payment.status === "CONFIRMED") return { error: "Payment already confirmed" }

  // Commission base = subtotal minus any discount applied
  const commissionBase = Number(order.subtotal) - Number(order.discountAmount)

  await prisma.$transaction(async (tx) => {
    // Confirm payment
    await tx.payment.update({
      where: { id: order.payment!.id },
      data: {
        status: "CONFIRMED",
        confirmedBy: session.user.id,
        confirmedAt: new Date(),
      },
    })

    // Update order status
    await tx.order.update({
      where: { id: orderId },
      data: { status: "PAYMENT_COMPLETE" },
    })

    // Create affiliate commission if applicable (tiered rate resolution)
    if (order.affiliateId && order.affiliate) {
      const rate = await resolveCommissionRate(
        order.affiliateId,
        order.items.map((i) => ({ productId: i.productId }))
      )
      const commission = commissionBase * (rate / 100)

      await tx.affiliateCommission.create({
        data: {
          affiliateId: order.affiliateId,
          orderId: order.id,
          amount: commission,
          rate,
          type: "DIRECT",
          status: "PENDING",
        },
      })

      // Create parent affiliate commission if applicable
      if (order.affiliate.parentId && order.affiliate.parent) {
        const parentRate = await resolveParentCommissionRate()
        const parentCommission = commissionBase * (parentRate / 100)

        await tx.affiliateCommission.create({
          data: {
            affiliateId: order.affiliate.parentId,
            orderId: order.id,
            amount: parentCommission,
            rate: parentRate,
            type: "PARENT",
            status: "PENDING",
          },
        })
      }
    }
  })

  if (order.user?.email) {
    void notifyCustomerStatusChanged(order.user.email, order.orderNumber, "PAYMENT_COMPLETE")
  }

  revalidatePath(`/admin/orders/${orderId}`)
  revalidatePath("/admin/orders")
  return { success: true }
}

export async function updateOrderStatus(
  orderId: string,
  status: OrderStatus
): Promise<{ success: boolean; error?: string }> {
  try {
    await requireAdmin()

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      select: { orderNumber: true, user: { select: { email: true } } },
    })

    await prisma.order.update({
      where: { id: orderId },
      data: { status },
    })

    if (order?.user?.email) {
      void notifyCustomerStatusChanged(order.user.email, order.orderNumber, status)
    }

    revalidatePath(`/admin/orders/${orderId}`)
    revalidatePath("/admin/orders")
    return { success: true }
  } catch {
    return { success: false, error: "Failed to update order status" }
  }
}

export async function resendStatusEmail(
  orderId: string
): Promise<{ success: boolean; error?: string }> {
  try {
    await requireAdmin()

    const order = await prisma.order.findUnique({
      where: { id: orderId },
      select: { orderNumber: true, status: true, user: { select: { email: true } } },
    })

    if (!order) return { success: false, error: "Order not found" }
    if (!order.user?.email) return { success: false, error: "No email address for this customer" }

    await notifyCustomerStatusChanged(order.user.email, order.orderNumber, order.status)
    return { success: true }
  } catch {
    return { success: false, error: "Failed to send email" }
  }
}

export async function addAdminNote(orderId: string, note: string) {
  await requireAdmin()

  await prisma.order.update({
    where: { id: orderId },
    data: { adminNotes: note },
  })

  revalidatePath(`/admin/orders/${orderId}`)
  return { success: true }
}
