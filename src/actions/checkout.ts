"use server"

import { prisma } from "@/lib/prisma"
import { auth } from "@/auth"
import { cookies } from "next/headers"
import { redirect } from "next/navigation"
import { addressSchema } from "@/lib/validations/checkout"
import { generateOrderNumber } from "@/lib/utils"
import { getSetting } from "@/lib/settings"
import { DEFAULT_AFFILIATE_DISCOUNT_RATE } from "@/lib/constants"
import { formatCurrency } from "@/lib/utils"
import type { PaymentMethod } from "@prisma/client"
import { notifyAdminNewOrder, notifyCustomerOrderPlaced, notifyAdminLowStock, notifyAdminOutOfStock } from "@/lib/email/notify"

export async function createOrder(formData: FormData) {
  const session = await auth()
  if (!session?.user?.id) {
    redirect("/login?returnUrl=/checkout")
  }

  // Validate address
  const addressData = {
    firstName: formData.get("firstName") as string,
    lastName: formData.get("lastName") as string,
    line1: formData.get("line1") as string,
    line2: (formData.get("line2") as string) || undefined,
    city: formData.get("city") as string,
    state: formData.get("state") as string,
    postalCode: formData.get("postalCode") as string,
    country: "US",
    phone: formData.get("phone") as string,
  }

  const validatedAddress = addressSchema.safeParse(addressData)
  if (!validatedAddress.success) {
    return { error: validatedAddress.error.issues[0].message }
  }

  const paymentMethod = formData.get("paymentMethod") as PaymentMethod
  if (!["VENMO", "CASHAPP", "BITCOIN"].includes(paymentMethod)) {
    return { error: "Please select a payment method" }
  }

  // Get cart
  const cart = await prisma.cart.findUnique({
    where: { userId: session.user.id },
    include: {
      items: {
        include: {
          product: true,
          variant: true,
        },
      },
    },
  })

  if (!cart || cart.items.length === 0) {
    return { error: "Your cart is empty" }
  }

  // Calculate subtotal
  const subtotal = cart.items.reduce((sum, item) => {
    const price = item.variant ? Number(item.variant.price) : Number(item.product.basePrice)
    return sum + price * item.quantity
  }, 0)

  // Process discount code (manual entry takes priority over cookie)
  const couponCode = (formData.get("couponCode") as string)?.trim().toUpperCase() || null
  const cookieStore = await cookies()
  const affiliateRef = cookieStore.get("affiliate_ref")?.value

  // Resolve affiliate attribution (safe outside transaction — no race condition)
  let affiliateId: string | null = null
  const codeToCheck = couponCode || (affiliateRef ? affiliateRef.toUpperCase() : null)

  if (codeToCheck) {
    const affiliate = await prisma.affiliate.findUnique({ where: { referralCode: codeToCheck, status: "APPROVED" } })
    if (affiliate) affiliateId = affiliate.id
  }
  if (!affiliateId && affiliateRef) {
    const cookieAffiliate = await prisma.affiliate.findUnique({ where: { referralCode: affiliateRef, status: "APPROVED" } })
    if (cookieAffiliate) affiliateId = cookieAffiliate.id
  }

  const taxRateStr = await getSetting("tax_rate")
  const shippingRateStr = await getSetting("shipping_flat_rate")
  const taxRate = parseFloat(taxRateStr) || 0
  const shippingCost = parseFloat(shippingRateStr) || 0

  const orderNumber = generateOrderNumber()

  // All discount calculation, stock checks, and order creation inside one transaction
  const order = await prisma.$transaction(async (tx) => {
    // Re-validate coupon inside transaction to prevent race conditions
    let couponId: string | null = null
    let discountAmount = 0
    let appliedCode: string | null = null

    if (codeToCheck) {
      const coupon = await tx.coupon.findUnique({ where: { code: codeToCheck } })

      if (coupon && coupon.isActive) {
        const validCoupon =
          (!coupon.expiresAt || coupon.expiresAt > new Date()) &&
          (!coupon.startsAt || coupon.startsAt <= new Date()) &&
          (!coupon.maxUses || coupon.usedCount < coupon.maxUses) &&
          (!coupon.minOrderAmount || subtotal >= Number(coupon.minOrderAmount))

        if (validCoupon) {
          couponId = coupon.id
          appliedCode = coupon.code
          if (coupon.discountType === "PERCENTAGE") {
            discountAmount = subtotal * (Number(coupon.discountValue) / 100)
          } else {
            discountAmount = Math.min(Number(coupon.discountValue), subtotal)
          }
        }
      } else if (!coupon && affiliateId) {
        // Affiliate code only — apply affiliate discount
        const discountRateStr = await getSetting("affiliate_discount_rate")
        const discountRate = parseFloat(discountRateStr) || DEFAULT_AFFILIATE_DISCOUNT_RATE
        discountAmount = subtotal * (discountRate / 100)
        appliedCode = codeToCheck
      }
    }

    // Affiliate cookie fallback for discount
    if (!appliedCode && affiliateId) {
      const discountRateStr = await getSetting("affiliate_discount_rate")
      const discountRate = parseFloat(discountRateStr) || DEFAULT_AFFILIATE_DISCOUNT_RATE
      discountAmount = subtotal * (discountRate / 100)
      appliedCode = affiliateRef?.toUpperCase() || null
    }

    discountAmount = Math.round(discountAmount * 100) / 100
    const discountedSubtotal = subtotal - discountAmount
    const tax = discountedSubtotal * (taxRate / 100)
    const total = discountedSubtotal + tax + shippingCost

    // Verify stock availability before creating order
    for (const item of cart.items) {
      if (item.variantId) {
        const variant = await tx.productVariant.findUnique({ where: { id: item.variantId } })
        if (!variant || variant.stock < item.quantity) {
          throw new Error(`Insufficient stock for ${item.product.name}${item.variant?.name ? ` — ${item.variant.name}` : ""}`)
        }
      } else {
        const product = await tx.product.findUnique({ where: { id: item.productId } })
        if (!product || product.stock < item.quantity) {
          throw new Error(`Insufficient stock for ${item.product.name}`)
        }
      }
    }

    // Save address
    const address = await tx.address.create({
      data: {
        userId: session.user.id,
        ...validatedAddress.data,
      },
    })

    // Create order
    const newOrder = await tx.order.create({
      data: {
        orderNumber,
        userId: session.user.id,
        addressId: address.id,
        status: "AWAITING_PAYMENT",
        subtotal,
        tax,
        shippingCost,
        discountAmount,
        total,
        affiliateId,
        couponId,
        couponCode: appliedCode,
        shippingAddress: validatedAddress.data,
        items: {
          create: cart.items.map((item) => ({
            productId: item.productId,
            variantId: item.variantId,
            name: item.product.name,
            variantName: item.variant?.name || null,
            sku: item.variant?.sku || item.product.sku || null,
            price: item.variant ? Number(item.variant.price) : Number(item.product.basePrice),
            quantity: item.quantity,
            total: (item.variant ? Number(item.variant.price) : Number(item.product.basePrice)) * item.quantity,
          })),
        },
        payment: {
          create: {
            method: paymentMethod,
            status: "PENDING",
            amount: total,
          },
        },
      },
    })

    // Increment coupon usage (inside transaction — race-safe)
    if (couponId) {
      await tx.coupon.update({
        where: { id: couponId },
        data: { usedCount: { increment: 1 } },
      })
    }

    // Decrement stock (already verified above)
    for (const item of cart.items) {
      if (item.variantId) {
        await tx.productVariant.update({
          where: { id: item.variantId },
          data: { stock: { decrement: item.quantity } },
        })
      } else {
        await tx.product.update({
          where: { id: item.productId },
          data: { stock: { decrement: item.quantity } },
        })
      }
    }

    // Clear cart
    await tx.cartItem.deleteMany({ where: { cartId: cart.id } })

    return newOrder
  }).catch((err: Error) => {
    if (err.message.startsWith("Insufficient stock")) {
      return { error: err.message } as const
    }
    throw err
  })

  if ("error" in order) {
    return { error: order.error }
  }

  // Email notifications (fire-and-forget)
  void notifyAdminNewOrder(
    orderNumber,
    formatCurrency(Number(order.total)),
    session.user.name || "Customer"
  )
  void notifyCustomerOrderPlaced(
    session.user.email!,
    orderNumber,
    formatCurrency(Number(order.total)),
    paymentMethod,
    cart.items.map((item) => ({
      name: item.product.name + (item.variant?.name ? ` — ${item.variant.name}` : ""),
      quantity: item.quantity,
      price: formatCurrency(
        (item.variant ? Number(item.variant.price) : Number(item.product.basePrice)) * item.quantity
      ),
    }))
  )

  // Low stock & out-of-stock alerts
  const lowStockThreshold = parseInt(await getSetting("low_stock_threshold") || "10") || 10
  for (const item of cart.items) {
    if (item.variantId && item.variant) {
      const newStock = item.variant.stock - item.quantity
      const name = item.product.name + (item.variant.name ? ` — ${item.variant.name}` : "")
      if (newStock <= 0) {
        void notifyAdminOutOfStock(name)
      } else if (newStock < lowStockThreshold) {
        void notifyAdminLowStock(name, newStock)
      }
    } else if (!item.variantId) {
      const newStock = item.product.stock - item.quantity
      if (newStock <= 0) {
        void notifyAdminOutOfStock(item.product.name)
      } else if (newStock < lowStockThreshold) {
        void notifyAdminLowStock(item.product.name, newStock)
      }
    }
  }

  redirect(`/checkout/confirmation?orderId=${order.id}`)
}

export async function submitPaymentConfirmation(orderId: string, transactionRef: string) {
  const session = await auth()
  if (!session?.user?.id) return { error: "Not authenticated" }

  const order = await prisma.order.findUnique({
    where: { id: orderId, userId: session.user.id },
    include: { payment: true },
  })

  if (!order) return { error: "Order not found" }
  if (!order.payment) return { error: "No payment record found" }
  if (order.payment.status !== "PENDING") return { error: "Payment already submitted" }

  await prisma.payment.update({
    where: { id: order.payment.id },
    data: {
      status: "SUBMITTED",
      transactionRef: transactionRef || null,
    },
  })

  return { success: true }
}
